{"version":3,"sources":["../../../src/lib/logger.ts","../../../src/lib/rateLimit.ts","../../../src/lib/apiHelpers.ts","../../../src/app/api/cron/daily-motivation/route.ts","../../../node_modules/next/dist/esm/build/templates/app-route.js"],"sourcesContent":["// ============================================================================\n// CENTRALIZED ERROR LOGGING SERVICE\n// ============================================================================\n// Provides structured error logging with context, ready for integration with\n// external services like Sentry, LogRocket, or custom analytics.\n\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\" | \"critical\";\n\ninterface ErrorContext {\n    userId?: string;\n    action?: string;\n    component?: string;\n    metadata?: Record<string, unknown>;\n}\n\ninterface LogEntry {\n    timestamp: string;\n    level: LogLevel;\n    message: string;\n    error?: Error | unknown;\n    context?: ErrorContext;\n    stack?: string;\n}\n\n// In-memory log buffer (for development/debugging)\nconst LOG_BUFFER_SIZE = 100;\nconst logBuffer: LogEntry[] = [];\n\n/**\n * Main logging function\n */\nfunction log(\n    level: LogLevel,\n    message: string,\n    error?: Error | unknown,\n    context?: ErrorContext\n): void {\n    const entry: LogEntry = {\n        timestamp: new Date().toISOString(),\n        level,\n        message,\n        error,\n        context,\n        stack: error instanceof Error ? error.stack : undefined,\n    };\n\n    // Add to buffer (circular)\n    logBuffer.push(entry);\n    if (logBuffer.length > LOG_BUFFER_SIZE) {\n        logBuffer.shift();\n    }\n\n    // Console output with styling\n    const styles = {\n        debug: \"color: gray\",\n        info: \"color: blue\",\n        warn: \"color: orange\",\n        error: \"color: red\",\n        critical: \"color: white; background: red; font-weight: bold\",\n    };\n\n    const prefix = `[${entry.timestamp}] [${level.toUpperCase()}]`;\n\n    if (typeof window !== \"undefined\") {\n        // Client-side logging\n        console.log(`%c${prefix} ${message}`, styles[level], context || \"\");\n        if (error) {\n            console.error(error);\n        }\n    } else {\n        // Server-side logging (plain text)\n        console.log(`${prefix} ${message}`, context ? JSON.stringify(context) : \"\");\n        if (error) {\n            console.error(error);\n        }\n    }\n\n    // TODO: Send to external service (Sentry, LogRocket, etc.)\n    // if (level === \"error\" || level === \"critical\") {\n    //   sendToSentry(entry);\n    // }\n}\n\n/**\n * Logger API\n */\nexport const logger = {\n    debug: (message: string, context?: ErrorContext) =>\n        log(\"debug\", message, undefined, context),\n\n    info: (message: string, context?: ErrorContext) =>\n        log(\"info\", message, undefined, context),\n\n    warn: (message: string, error?: Error | unknown, context?: ErrorContext) =>\n        log(\"warn\", message, error, context),\n\n    error: (message: string, error?: Error | unknown, context?: ErrorContext) =>\n        log(\"error\", message, error, context),\n\n    critical: (message: string, error?: Error | unknown, context?: ErrorContext) =>\n        log(\"critical\", message, error, context),\n\n    /**\n     * Log a Firestore operation error with context\n     */\n    firestoreError: (\n        operation: string,\n        error: unknown,\n        userId?: string,\n        documentId?: string\n    ) => {\n        log(\"error\", `Firestore ${operation} failed`, error, {\n            userId,\n            action: operation,\n            component: \"Firestore\",\n            metadata: { documentId },\n        });\n    },\n\n    /**\n     * Log an API request error\n     */\n    apiError: (\n        endpoint: string,\n        method: string,\n        error: unknown,\n        statusCode?: number\n    ) => {\n        log(\"error\", `API ${method} ${endpoint} failed`, error, {\n            action: `${method} ${endpoint}`,\n            component: \"API\",\n            metadata: { statusCode },\n        });\n    },\n\n    /**\n     * Get recent logs (for debugging)\n     */\n    getRecentLogs: (count: number = 20): LogEntry[] => {\n        return logBuffer.slice(-count);\n    },\n\n    /**\n     * Clear log buffer\n     */\n    clearLogs: () => {\n        logBuffer.length = 0;\n    },\n};\n\n/**\n * Helper to wrap async functions with automatic error logging\n */\nexport function withLogging<T extends (...args: unknown[]) => Promise<unknown>>(\n    fn: T,\n    context: { action: string; component: string }\n): T {\n    return (async (...args: Parameters<T>) => {\n        try {\n            return await fn(...args);\n        } catch (error) {\n            logger.error(`${context.action} failed`, error, context);\n            throw error;\n        }\n    }) as T;\n}\n","// ============================================================================\n// RATE LIMITING UTILITIES - ENHANCED VERSION\n// ============================================================================\n// Provides rate limiting for API routes to prevent abuse and ensure fair usage.\n// Supports multiple rate limit configurations for different endpoint types.\n\nimport { NextRequest, NextResponse } from \"next/server\";\n\n// In-memory store for rate limiting (for serverless, consider using Upstash Redis)\nconst rateLimitStore = new Map<string, { count: number; resetTime: number }>();\n\ninterface RateLimitConfig {\n  windowMs: number; // Time window in milliseconds\n  maxRequests: number; // Maximum requests per window\n  message?: string; // Custom error message\n  keyPrefix?: string; // Custom key prefix\n}\n\n// Preset configurations for different endpoint types\nconst RATE_LIMIT_PRESETS = {\n  // Stricter limits for authentication endpoints\n  auth: {\n    windowMs: 60 * 1000, // 1 minute\n    maxRequests: 5, // 5 attempts per minute\n    message: \"Too many authentication attempts. Please try again in a minute.\",\n    keyPrefix: \"rl_auth_\",\n  },\n  // AI endpoints - expensive operations\n  ai: {\n    windowMs: 60 * 1000, // 1 minute\n    maxRequests: 20, // 20 requests per minute\n    message: \"AI request limit reached. Please try again in a minute.\",\n    keyPrefix: \"rl_ai_\",\n  },\n  // General API endpoints\n  default: {\n    windowMs: 60 * 1000, // 1 minute\n    maxRequests: 100, // 100 requests per minute\n    message: \"Too many requests. Please try again later.\",\n    keyPrefix: \"rl_\",\n  },\n  // Leaderboard - read-heavy, cache longer\n  leaderboard: {\n    windowMs: 60 * 1000, // 1 minute\n    maxRequests: 30, // 30 requests per minute\n    message: \"Leaderboard request limit reached. Please try again later.\",\n    keyPrefix: \"rl_leaderboard_\",\n  },\n};\n\nconst DEFAULT_CONFIG: RateLimitConfig = {\n  windowMs: 60 * 1000, // 1 minute\n  maxRequests: 60, // 60 requests per minute\n  message: \"Too many requests. Please try again later.\",\n  keyPrefix: \"rl_\",\n};\n\n/**\n * Get client identifier from request\n */\nfunction getClientId(request: NextRequest): string {\n  // Try to get IP from various headers (Vercel, Cloudflare, etc.)\n  const forwarded = request.headers.get(\"x-forwarded-for\");\n  const realIp = request.headers.get(\"x-real-ip\");\n  const cfConnectingIp = request.headers.get(\"cf-connecting-ip\");\n\n  // Fallback to a default identifier\n  return forwarded?.split(\",\")[0] || realIp || cfConnectingIp || \"anonymous\";\n}\n\n/**\n * Clean up expired entries (called periodically)\n */\nfunction cleanupExpiredEntries(): void {\n  const now = Date.now();\n  for (const [key, value] of rateLimitStore.entries()) {\n    if (now > value.resetTime) {\n      rateLimitStore.delete(key);\n    }\n  }\n}\n\n/**\n * Check if request should be rate limited\n */\nexport function checkRateLimit(\n  request: NextRequest,\n  config: Partial<RateLimitConfig> = {}\n): { allowed: boolean; remaining: number; resetTime: number; limit: number } {\n  const { windowMs, maxRequests, keyPrefix } = { ...DEFAULT_CONFIG, ...config };\n\n  const clientId = getClientId(request);\n  const prefix = keyPrefix || DEFAULT_CONFIG.keyPrefix;\n  const key = `${prefix}${clientId}`;\n  const now = Date.now();\n\n  // Cleanup old entries periodically (1% chance per request)\n  if (Math.random() < 0.01) {\n    cleanupExpiredEntries();\n  }\n\n  const existing = rateLimitStore.get(key);\n\n  if (!existing || now > existing.resetTime) {\n    // New window\n    rateLimitStore.set(key, {\n      count: 1,\n      resetTime: now + windowMs,\n    });\n    return {\n      allowed: true,\n      remaining: maxRequests - 1,\n      resetTime: now + windowMs,\n      limit: maxRequests,\n    };\n  }\n\n  if (existing.count >= maxRequests) {\n    // Rate limited\n    return {\n      allowed: false,\n      remaining: 0,\n      resetTime: existing.resetTime,\n      limit: maxRequests,\n    };\n  }\n\n  // Increment counter\n  existing.count++;\n  return {\n    allowed: true,\n    remaining: maxRequests - existing.count,\n    resetTime: existing.resetTime,\n    limit: maxRequests,\n  };\n}\n\n/**\n * Rate limiting middleware for API routes\n */\nexport function withRateLimit(\n  request: NextRequest,\n  config: Partial<RateLimitConfig> = {}\n): NextResponse | null {\n  const result = checkRateLimit(request, config);\n  const { message } = { ...DEFAULT_CONFIG, ...config };\n\n  if (!result.allowed) {\n    const retryAfter = Math.ceil((result.resetTime - Date.now()) / 1000);\n    return NextResponse.json(\n      {\n        error: \"Too Many Requests\",\n        message: message,\n        retryAfter: retryAfter,\n      },\n      {\n        status: 429,\n        headers: {\n          \"Retry-After\": retryAfter.toString(),\n          \"X-RateLimit-Limit\": String(result.limit),\n          \"X-RateLimit-Remaining\": \"0\",\n          \"X-RateLimit-Reset\": String(Math.ceil(result.resetTime / 1000)),\n        },\n      }\n    );\n  }\n\n  // Add rate limit headers to successful responses\n  const response = NextResponse.next();\n  response.headers.set(\"X-RateLimit-Limit\", String(result.limit));\n  response.headers.set(\"X-RateLimit-Remaining\", String(result.remaining));\n  response.headers.set(\"X-RateLimit-Reset\", String(Math.ceil(result.resetTime / 1000)));\n\n  return response;\n}\n\n/**\n * Use a preset configuration by name\n */\nexport function withPreset(\n  request: NextRequest,\n  presetName: keyof typeof RATE_LIMIT_PRESETS\n): NextResponse | null {\n  return withRateLimit(request, RATE_LIMIT_PRESETS[presetName]);\n}\n\n/**\n * Higher-order function to wrap API handlers with rate limiting\n */\nexport function rateLimited<T extends (request: NextRequest) => Promise<NextResponse>>(\n  handler: T,\n  config: Partial<RateLimitConfig> = {}\n): T {\n  return (async (request: NextRequest) => {\n    const rateLimitResponse = withRateLimit(request, config);\n    if (rateLimitResponse) {\n      return rateLimitResponse;\n    }\n    return handler(request);\n  }) as T;\n}\n\n/**\n * Create a rate limit middleware function with a specific preset\n */\nexport function createRateLimiter(presetName: keyof typeof RATE_LIMIT_PRESETS) {\n  return (request: NextRequest) => withPreset(request, presetName);\n}\n\n// Export presets for external use\nexport { RATE_LIMIT_PRESETS };\nexport type { RateLimitConfig };\n","// ============================================================================\n// API ROUTE WRAPPER - ERROR HANDLING & VALIDATION\n// ============================================================================\n// Provides higher-order functions for standardizing API route behavior\n// with proper error handling, validation, and response formatting.\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { z, ZodError } from 'zod';\nimport { checkRateLimit, RATE_LIMIT_PRESETS } from './rateLimit';\nimport { logger } from './logger';\n\n// ============================================================================\n// ERROR TYPES\n// ============================================================================\n\nexport class ApiError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number = 500,\n    public code: string = 'INTERNAL_ERROR',\n    public details?: Record<string, unknown>,\n    public retryAfter?: number\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\nexport class ValidationError extends ApiError {\n  constructor(message: string, public fieldErrors?: Record<string, string[]>) {\n    super(message, 400, 'VALIDATION_ERROR', { fieldErrors });\n  }\n}\n\nexport class AuthenticationError extends ApiError {\n  constructor(message: string = 'Authentication required') {\n    super(message, 401, 'UNAUTHORIZED');\n  }\n}\n\nexport class AuthorizationError extends ApiError {\n  constructor(message: string = 'Permission denied') {\n    super(message, 403, 'FORBIDDEN');\n  }\n}\n\nexport class NotFoundError extends ApiError {\n  constructor(resource: string = 'Resource') {\n    super(`${resource} not found`, 404, 'NOT_FOUND');\n  }\n}\n\nexport class RateLimitError extends ApiError {\n  constructor(message: string, retryAfter?: number) {\n    super(message, 429, 'RATE_LIMIT_EXCEEDED', { retryAfter }, retryAfter);\n  }\n}\n\n// ============================================================================\n// ERROR HANDLER\n// ============================================================================\n\nexport function handleApiError(error: unknown, context?: string): NextResponse {\n  // Log the error\n  logger.apiError(context || 'API', 'UNKNOWN', error, 500);\n\n  // Handle Zod validation errors\n  if (error instanceof ZodError) {\n    const fieldErrors: Record<string, string[]> = {};\n    const zodError = error as unknown as ZodError<unknown>;\n    zodError.issues.forEach((e) => {\n      const path = e.path.join('.');\n      if (!fieldErrors[path]) {\n        fieldErrors[path] = [];\n      }\n      fieldErrors[path].push(e.message);\n    });\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: 'Validation failed',\n        code: 'VALIDATION_ERROR',\n        details: { fieldErrors },\n      },\n      { status: 400 }\n    );\n  }\n\n  // Handle custom API errors\n  if (error instanceof ApiError) {\n    const response: Record<string, unknown> = {\n      success: false,\n      error: error.message,\n      code: error.code,\n    };\n\n    if (error.details) {\n      response.details = error.details;\n    }\n\n    if (error.retryAfter) {\n      response.retryAfter = error.retryAfter;\n    }\n\n    return NextResponse.json(response, { status: error.statusCode });\n  }\n\n  // Handle Firebase errors\n  if (error instanceof Error) {\n    const errorCode = (error as { code?: string }).code;\n\n    if (errorCode?.startsWith('auth/')) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'Authentication failed',\n          code: 'AUTH_ERROR',\n        },\n        { status: 401 }\n      );\n    }\n\n    if (errorCode === 'permission-denied') {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'You do not have permission to perform this action',\n          code: 'PERMISSION_DENIED',\n        },\n        { status: 403 }\n      );\n    }\n  }\n\n  // Handle unknown errors\n  console.error('Unhandled API error:', error);\n  return NextResponse.json(\n    {\n      success: false,\n      error: 'An unexpected error occurred',\n      code: 'INTERNAL_ERROR',\n    },\n    { status: 500 }\n  );\n}\n\n// ============================================================================\n// API ROUTE OPTIONS\n// ============================================================================\n\ninterface RouteOptions {\n  // Authentication\n  requireAuth?: boolean;\n\n  // Rate limiting\n  rateLimit?: keyof typeof RATE_LIMIT_PRESETS;\n\n  // Validation\n  validate?: {\n    body?: z.ZodSchema;\n    query?: z.ZodSchema;\n    params?: z.ZodSchema;\n  };\n\n  // Caching\n  cache?: {\n    maxAge?: number;\n    swr?: number;\n  };\n\n  // Logging\n  logRequest?: boolean;\n}\n\n// ============================================================================\n// API ROUTE WRAPPER\n// ============================================================================\n\nexport function createApiRoute<T = unknown>(\n  handler: (request: NextRequest, context: { params?: Record<string, string> }) => Promise<T>,\n  options: RouteOptions = {}\n) {\n  return async function (request: NextRequest, context: { params?: Record<string, string> }) {\n    const startTime = Date.now();\n\n    try {\n      // 1. Check rate limiting\n      if (options.rateLimit) {\n        const rateLimitResult = checkRateLimit(request, RATE_LIMIT_PRESETS[options.rateLimit]);\n\n        if (!rateLimitResult.allowed) {\n          throw new RateLimitError(\n            RATE_LIMIT_PRESETS[options.rateLimit].message || 'Rate limit exceeded',\n            Math.ceil((rateLimitResult.resetTime - Date.now()) / 1000)\n          );\n        }\n      }\n\n      // 2. Validate request body\n      if (options.validate?.body) {\n        try {\n          const body = await request.json();\n          options.validate.body.parse(body);\n        } catch (error) {\n          if (error instanceof ZodError) {\n            throw new ValidationError('Invalid request body', error.flatten().fieldErrors);\n          }\n          throw new ValidationError('Invalid JSON in request body');\n        }\n      }\n\n      // 3. Validate query parameters\n      if (options.validate?.query && request.nextUrl.search) {\n        const searchParams = Object.fromEntries(request.nextUrl.searchParams.entries());\n        try {\n          options.validate.query.parse(searchParams);\n        } catch (error) {\n          if (error instanceof ZodError) {\n            throw new ValidationError('Invalid query parameters', error.flatten().fieldErrors);\n          }\n        }\n      }\n\n      // 4. Execute handler\n      const result = await handler(request, context);\n\n      // 5. Log request\n      if (options.logRequest) {\n        const duration = Date.now() - startTime;\n        logger.info('API request completed', {\n          metadata: {\n            method: request.method,\n            url: request.url,\n            status: 200,\n            duration,\n          }\n        });\n      }\n\n      // 6. Return response with caching headers\n      const response = NextResponse.json({ success: true, data: result });\n\n      if (options.cache) {\n        if (options.cache.swr) {\n          response.headers.set(\n            'Cache-Control',\n            `public, s-maxage=${options.cache.maxAge || 60}, stale-while-revalidate=${options.cache.swr}`\n          );\n        } else if (options.cache.maxAge) {\n          response.headers.set(\n            'Cache-Control',\n            `public, max-age=${options.cache.maxAge}, immutable`\n          );\n        }\n      }\n\n      return response;\n    } catch (error) {\n      return handleApiError(error, `${request.method} ${request.url}`);\n    }\n  };\n}\n\n// ============================================================================\n// RATE LIMIT WRAPPER\n// ============================================================================\n\ntype RouteHandler = (request: NextRequest) => Promise<NextResponse>;\n\ninterface RateLimitConfig {\n  maxRequests: number;\n  windowMs: number;\n  identifier?: string;\n  message?: string;\n}\n\ntype RateLimitPreset = keyof typeof RATE_LIMIT_PRESETS;\n\nexport function withRateLimit(\n  handler: RouteHandler,\n  config: RateLimitPreset | Partial<RateLimitConfig> = 'default'\n): RouteHandler {\n  const rateLimitConfig = typeof config === 'string' \n    ? RATE_LIMIT_PRESETS[config]\n    : { \n        windowMs: config.windowMs || 60000, \n        maxRequests: config.maxRequests || 100, \n        message: config.message,\n        keyPrefix: config.identifier ? `rl_${config.identifier}_` : 'rl_'\n      };\n\n  return async (request: NextRequest): Promise<NextResponse> => {\n    const rateLimitResult = checkRateLimit(request, rateLimitConfig);\n\n    if (!rateLimitResult.allowed) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: rateLimitConfig.message || 'Rate limit exceeded',\n          code: 'RATE_LIMIT_EXCEEDED',\n          retryAfter: Math.ceil((rateLimitResult.resetTime - Date.now()) / 1000),\n        },\n        {\n          status: 429,\n          headers: {\n            'Retry-After': String(Math.ceil((rateLimitResult.resetTime - Date.now()) / 1000)),\n          },\n        }\n      );\n    }\n\n    return handler(request);\n  };\n}\n\n// ============================================================================\n// ASYNC WRAPPER FOR SAFETY\n// ============================================================================\n\ninterface ErrorHandlingOptions {\n  endpoint?: string;\n  method?: string;\n  skipRateLimit?: boolean;\n}\n\nexport function withErrorHandling<T extends RouteHandler>(\n  fn: T, \n  _options?: ErrorHandlingOptions\n): T {\n  return (async (request: NextRequest): Promise<NextResponse> => {\n    try {\n      return await fn(request);\n    } catch (error) {\n      console.error('Function error:', error);\n      throw error;\n    }\n  }) as T;\n}\n\n// ============================================================================\n// RESPONSE HELPERS\n// ============================================================================\n\nexport function successResponse<T>(data: T, status = 200): NextResponse {\n  return NextResponse.json(\n    { success: true, data },\n    { status }\n  );\n}\n\nexport function errorResponse(\n  message: string,\n  code: string = 'ERROR',\n  status: number = 400,\n  details?: Record<string, unknown>\n): NextResponse {\n  return NextResponse.json(\n    { success: false, error: message, code, details },\n    { status }\n  );\n}\n\nexport function created<T>(data: T): NextResponse {\n  return successResponse(data, 201);\n}\n\nexport function noContent(): NextResponse {\n  return new NextResponse(null, { status: 204 });\n}\n\n// ============================================================================\n// PAGINATION HELPERS\n// ============================================================================\n\ninterface PaginationParams {\n  page?: number;\n  limit?: number;\n  orderBy?: string;\n  order?: 'asc' | 'desc';\n}\n\ninterface PaginationResult<T> {\n  data: T[];\n  pagination: {\n    page: number;\n    limit: number;\n    total: number;\n    totalPages: number;\n    hasMore: boolean;\n  };\n}\n\nexport function parsePagination(request: NextRequest): PaginationParams {\n  const searchParams = request.nextUrl.searchParams;\n\n  return {\n    page: Math.max(1, parseInt(searchParams.get('page') || '1', 10)),\n    limit: Math.min(100, Math.max(1, parseInt(searchParams.get('limit') || '20', 10))),\n    orderBy: searchParams.get('orderBy') || 'createdAt',\n    order: (searchParams.get('order') as 'asc' | 'desc') || 'desc',\n  };\n}\n\nexport function paginateResponse<T>(\n  data: T[],\n  params: PaginationParams,\n  total: number\n): PaginationResult<T> {\n  const { page = 1, limit = 20 } = params;\n  const totalPages = Math.ceil(total / limit);\n  const start = (page - 1) * limit;\n  const end = start + limit;\n  const paginatedData = data.slice(start, end);\n\n  return {\n    data: paginatedData,\n    pagination: {\n      page,\n      limit,\n      total,\n      totalPages,\n      hasMore: page < totalPages,\n    },\n  };\n}\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n// All functions and classes are already exported at their definition sites\n// No additional exports needed here\n","// ============================================================================\n// DAILY MOTIVATION CRON JOB\n// ============================================================================\n// GET /api/cron/daily-motivation\n// Runs at 6 AM daily to prepare daily motivation messages for all users.\n// Schedule: 0 6 * * * (Every day at 6:00 AM UTC)\n\nimport { NextResponse } from \"next/server\";\nimport { db } from \"@/lib/firebase\";\nimport { collection, getDocs, doc, setDoc } from \"firebase/firestore\";\nimport { withErrorHandling } from \"@/lib/apiHelpers\";\nimport { logger } from \"@/lib/logger\";\n\n// Verify the request is from Vercel Cron\nfunction verifyCronRequest(request: Request): boolean {\n  const authHeader = request.headers.get(\"authorization\");\n  return authHeader === `Bearer ${process.env.CRON_SECRET}`;\n}\n\n/**\n * GET /api/cron/daily-motivation\n * Creates daily motivation notifications for all users\n */\nexport const GET = withErrorHandling(\n  async (_request: Request) => {\n    // In production, verify the cron secret\n    if (process.env.NODE_ENV === \"production\") {\n      if (!verifyCronRequest(_request)) {\n        return NextResponse.json(\n          { error: \"Unauthorized\", code: \"UNAUTHORIZED_CRON\" },\n          { status: 401 }\n        );\n      }\n    }\n\n    logger.info(\"Daily motivation cron job started\", { action: \"cron/daily-motivation\" });\n\n    const usersSnapshot = await getDocs(collection(db, \"users\"));\n    let notificationsCreated = 0;\n    let errors = 0;\n\n    const motivationalMessages = [\n      \"Consistency is key! Every journey starts with a single step.\",\n      \"You are capable of amazing things. Keep pushing!\",\n      \"Small progress is still progress. Keep going!\",\n      \"Your potential is endless. Go do what you were created to do.\",\n      \"Discipline is choosing between what you want now and what you want most.\",\n      \"Success is the sum of small efforts repeated day in and day out.\",\n      \"Don't watch the clock; do what it does. Keep going!\",\n      \"The only way to do great work is to love what you do.\",\n    ];\n\n    for (const userDoc of usersSnapshot.docs) {\n      try {\n        const userId = userDoc.id;\n        const randomMessage = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];\n\n        // Create notification in Firestore\n        const notificationRef = doc(collection(db, \"users\", userId, \"notifications\"));\n        await setDoc(notificationRef, {\n          type: \"info\",\n          title: \"Daily Motivation âœ¨\",\n          message: randomMessage,\n          createdAt: new Date().toISOString(),\n          read: false,\n        });\n\n        notificationsCreated++;\n      } catch (userError) {\n        errors++;\n        logger.warn(`Failed to create notification for user`, userError);\n      }\n    }\n\n    logger.info(`Daily motivation completed: ${notificationsCreated} notifications created, ${errors} errors`, {\n      action: \"cron/daily-motivation\",\n      metadata: { notificationsCreated, errors },\n    });\n\n    return NextResponse.json({\n      success: true,\n      message: `Daily motivation job completed`,\n      notificationsCreated,\n      errors,\n      timestamp: new Date().toISOString(),\n    });\n\n  },\n  { endpoint: \"/api/cron/daily-motivation\", method: \"GET\", skipRateLimit: true }\n);\n\nexport const dynamic = \"force-dynamic\";\n","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setManifestsSingleton } from \"next/dist/esm/server/app-render/manifests-singleton\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/cron/daily-motivation/route\",\n        pathname: \"/api/cron/daily-motivation\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/cron/daily-motivation/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/cron/daily-motivation/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        const silenceLog = false;\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, silenceLog, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            const silenceLog = false;\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            }, silenceLog, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n"],"names":[],"mappings":"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","ignoreList":[4]}